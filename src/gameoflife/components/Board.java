package gameoflife.components;

import static gameoflife.components.Cell.statusTypes;
import gameoflife.control.Algorithm;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.Iterator;
import java.util.Map;
import java.util.Observable;
import gameoflife.control.ClusterFinder;

import javax.swing.*;
/**
 *
 * @author Carlos Gutierrez
 */
public class Board extends Observable implements Runnable{
    private Algorithm al;
    private int boardSize;
    private Thread golthread;
    private GameZone gameZone;
    private String message;
    private ClusterFinder clusterFinder;
    public enum GameState{
        STARTED,
        STOPPED,
        STARTED_WITH_STATUS,
        STOPPED_WITH_STATUS
    }
    private GameState state; 
    
    /**
     * Constructor
     * @param boardSize The initial length of the sides of the game board
     */
    public Board(int boardSize){
       this.al =new Algorithm(boardSize);
       clusterFinder = new ClusterFinder(al.getCells());
       this.boardSize = boardSize;
       gameZone = new GameZone();
       state = GameState.STOPPED;
       fill();
    }
    
    /**
     * Initializes the game board filling it
     * with dead cells.
     */
    private void fill(){
        int sides = boardSize/Cell.sideValue;
        for (int i = 0; i < sides; i++) {
            for (int j = 0; j < sides; j++) {
                addCell(new Cell(i, j));
            }
        }
    }
    
    /**
     * Fills the game board in a random fashion
     */
    public void fillRandomly(){
        al.resetAliveCellCount();
        double val;
        Iterator i = al.getCells().entrySet().iterator();
        while(i.hasNext()) {
           Map.Entry<String, Cell> pairs = (Map.Entry)i.next();
           val = Math.random()*10;
           if(val > 5){
                pairs.getValue().setStatus(statusTypes.ALIVE);
                al.addAlive(true);
           }
           else{
               pairs.getValue().setStatus(statusTypes.DEAD);
           }
        }
        gameZone.repaint();
    } 
    
    /**
     * Used to know if there are alive cells in the board
     * Uses delegation to expose the getAliveCells method
     * from Algorithm
     * @return The number of currently alive cells
     */
    public int getAliveCells(){
        return al.getAliveCells();
    }
    
    /**
     * Generates the next generation of cells by kiling and reviving
     * Uses delegation to expose the createnextgen method
     * from Algorithm
     * @return If there are more posible moves for other generation
     */
    public boolean createnextGen(){
        boolean hasMoreMoves = al.createnextGen();
        gameZone.repaint();
        clusterFinder.reset();
        clusterFinder.findClusters();
        state = GameState.STARTED_WITH_STATUS;
        changed(clusterFinder.STATUS_STRING+clusterFinder.getNumberOfClusters());
        return hasMoreMoves;
    }
    
    public void findClusters(){
        clusterFinder.findClusters();
        state = GameState.STOPPED_WITH_STATUS;
        changed(clusterFinder.STATUS_STRING+clusterFinder.getNumberOfClusters());
    }
    
    public String getMessageString(){
        return clusterFinder.getMessageString();
    }
   
    /**
     * Adds a ne cell to the game board
     * Uses delegation to expose the addCell method
     * from Algorithm
     * @param cell The new cell to be added
     */
    public void addCell(Cell cell) {
        al.addCell(cell);
    }
   
    /**
     * Used to add a cell selected by the user
     * @param e The mouse event generated by the user
     */
    private void selectCell(MouseEvent e) {
        int x = e.getPoint().x/Cell.sideValue;
        int y = e.getPoint().y/Cell.sideValue;
        Cell cell = al.getCells().get(Cell.genKey(x, y));
        if(cell != null){
            toggleCell(cell);
        }
        gameZone.repaint();
    }
   
    /**
     * Used to revive/kill a cell if it is 
     * selected/unselected by the user
     * Uses delegation to expose the toggle cell method 
     * from Algorithm
     * @param cell The cell to be revived/killed
     */
    private void toggleCell(Cell cell){
        al.toggleCell(cell);
    }
    
    /**
     * Starts the game and notifies the Observers about it
     */
    public void startGame(){
        state = GameState.STARTED;
        golthread  = new Thread(this);
        golthread.start();
        changed("Game started!");
    }
    
    /**
     * Stops the game and notifies the Observers about it
     */
    public void stopGame(){
        doStop();
        changed("Game stopped!");
    }
    
    /**
     * Stops the game and notifies the Observers about it
     * Receives a custom message to send to the Observer
     * @param message 
     */
    public void stopGame(String message){
        doStop();
        changed(message);
    }
    
    /**
     * Used to keep the code DRY on the stopGame 
     * overloaded functions
     */
    private void doStop(){
        state = GameState.STOPPED;
        golthread.interrupt();
    }

    /**
     * Used to expose the game panel
     * @return The game panel
     */
    public JPanel getPanel(){
        return gameZone;
    }
    
    /**
     * Used to notify the Observers if the
     * game's state is changed
     * @param message Custom message to send to the Observer
     */
    private void changed(String message){
        setChanged();
        notifyObservers(message);
    }
    
    /**
     * Used to retreive the game state
     * @return The game state
     */
    public GameState getGameState(){
        return state;
    }
    
    /**
     * Used to clear the game board
     */
    public void reset(){
        al.resetAliveCellCount();
        Iterator i = al.getCells().entrySet().iterator();
        while(i.hasNext()) {
           Map.Entry<String, Cell> pairs = (Map.Entry)i.next();
           Cell cell = pairs.getValue();
           cell.setStatus(statusTypes.DEAD);
           cell.setInCluster(false);
        }
        gameZone.repaint();
        state = GameState.STOPPED_WITH_STATUS;
        changed("...");
    }

    /**
     * Stop the game if there aro no more
     * cells alive or if there are no
     * more movements to make
     */
    @Override
    public void run() {
        if(createnextGen()){
            if(al.getAliveCells() > 0){
                try {
                    Thread.sleep(1000);
                    run();
                } catch(Exception ex) {
                    stopGame();
                }
            }
            else{
                stopGame("No more cells alive!");
            }
        }
        else{
            stopGame("No more moves!");
        }
    }
    
    class GameZone extends JPanel implements MouseListener{
        
        public GameZone(){
            addMouseListener(this);
        }
        
        @Override
        public Dimension getPreferredSize() {
           return new Dimension(boardSize, boardSize);
        }

        @Override
        protected void paintComponent(Graphics g) {
           super.paintComponent(g);
           Graphics2D g2 = (Graphics2D) g;
           Iterator i = al.getCells().entrySet().iterator();
           while(i.hasNext()) {
              Map.Entry<String, Cell> pairs = (Map.Entry)i.next();
              Cell cell = pairs.getValue();
              Rectangle rect = new Rectangle(cell.getX()*Cell.sideValue, cell.getY()*Cell.sideValue, Cell.sideValue, Cell.sideValue);
              g2.draw(rect);
              if(cell.getStatus() == statusTypes.ALIVE){
                  g.fillRect(cell.getX()*Cell.sideValue, cell.getY()*Cell.sideValue, Cell.sideValue, Cell.sideValue);
              }
           }
        }

         @Override
         public void mouseClicked(MouseEvent e) {
             if(state == GameState.STOPPED || state == GameState.STOPPED_WITH_STATUS)
                selectCell(e);
         }

         @Override
         public void mousePressed(MouseEvent e) {

         }

         @Override
         public void mouseReleased(MouseEvent e) {

         }

         @Override
         public void mouseEntered(MouseEvent e) {

         }

         @Override
         public void mouseExited(MouseEvent e) {

         }
    }

}